- Exec重启，可能会出现下面几个问题：

    - 任务实例状态全部失败，需要手动重跑恢复

    - executor机器上的job进程并没有结束，如果手动恢复，可能出现同一个job同时跑了多份的情况。

- 原因是：

    - exec为job执行启动一个独立进程，并同步等待，重启难以恢复

    - job进程难以做到父进程变化自杀。难以感知到exec进程的状态，更无法在exec关闭的时候也自杀关闭。


为了能够提高exec任务重启时候的可用性，可以通过如下几个步骤实现任务状态的续作：

- 每个job进程启动时加上特定的进程参数，用于表示是这个是azkaban的job进程。

- exec在shutdown的时候先关闭exec，再将exec的子孙进程全部杀死，这样job的状态就保存在db中了，这一步需要修改exec的shutdown脚本。

- exec在启动时，对于有特定参数的进程，杀死其进程以及其子孙进程。这一步需要完善exec的启动脚本

- exec启动的时候，对于未完成的调度实例，进行续作，重启job进程，续作其作业。

- 这就保证了exec在重启的时候不会有任何任务的失败和重复，但是比较简单粗暴，job可能出现重做的情况，适用于job重做幂等（一个job穿行执行多次最终的业务数据不会有影响）的场景。

想要更加优雅的实现续作，可以这样做：

- exec记录每个job进程id，加上特定的进程参数，用于表示该进程是azkaban的job进程。

- job进程增加对exec的回调，exec不再同步等待，如果回调失败，持续等待回调

- exec启动的时候，对于未完成的调度实例，进行续作，重启拉起一个job进程。

- exec定期检查job进程，如果发现了某个job进程挂掉了，认为该job执行失败。如果没有这一步，单纯靠job进程回调，可能会出现job进程丢失，从而阻塞整个flow执行的情况。

- 如果确定exec要永久下线，对于有特定参数的进程，杀死该进程以及其子孙进程。

- 整个方法比上面的方案优雅很多，但是对job执行逻辑改动较多。

更进一步的优化，进行服务拆分：

- 从exec中抽离除专门负责job进程启动，监控逻辑，将其塞入一个新的服务job server中

- job server的逻辑尽量简洁单一，实现job续作，更新频率很低，因此升级、更新、重启的频率也会很低

- exec启动job和job server进行交互，exec向job server发送启动job的请求，并且轮训job进程的状态

- exec之间可以有权重的动态调整，重启前切空流量。如果需要重启某个exec服务上的job server，可以在重启前切空流量，不在接收新的任务，等jobserver上没有任务的时候重启升级。