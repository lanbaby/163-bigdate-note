## 如何实现web高可用

实现高可用就需要至少有两个以上的web节点，需要解决一下几个问题：

- 提供选主功能，只有选主成功的实例才能提供服务

    如果两个web节点同时调度，就会造成业务异常。所以必须要有一个选主方案，只有当前为主的web才能调度任务，从web作为主web的后备，当主web失效的时候能够升级为主web，保证系统整体可用。

- 主从之间需要能够同步元数据操作，元数据需要有版本

    当主节点收到对元数据进行操作的请求后，需要指挥从节点对内存中的数据进行相应的改动，这样才能保证从节点变成主节点后元数据是正确的。同时元数据也要有版本，这样从节点才能根据版本信息确认哪些元数据是过期的，需要重新加载同步。

- 主从切换的时候需要避免同时有2个实例同时服务

    由于网络延迟的原因，不同节点对自己身份变更的认知会有延迟，原来的主节点可能还未发现自己已经变成从节点，依然进行任务的调度，与此同时，新的主节点也开始进行任务的调度，这样就会导致业务异常。

![azkaban_web_reality][1]

## 如何实现web高可用-实现选主

场景和分布式锁类似。锁的存在就是为了解决共享资源的竞争和独享，而选主的场景就是多个web实例对leader身份的竞争和独享，因此可以给web实例之间设置一把锁。

- 加锁成功的实例成为主节点

    考虑到web实例是在不同的机器和进程，这把锁是一把分布式的锁。

- 每个节点只关心锁，不关心解锁，锁必须要有超时机制

    与常用分布式锁不同，web只需要关系加锁，不需要关心解锁。因为一旦加锁成功，意味着成为leader，web会尝试一直保持leader的身份，不会考虑主动释放锁，所以这里的分不是锁需要引入超时机制，以防止leader锁节点宕机，导致锁无法释放，无法重新选主的问题。

- 无论加锁是否成功，都需要时刻关注锁的状态（是否超时）

    对于从节点，必须在leader失效的时候第一时间抢占锁，尽量减少无主的空挡。而对于主节点，考虑到网络延迟、消息丢失等因素，有可能虽然自身服务没有问题，但是其实已经锁超时，丧失了leader身份，这个时候主节点必须能够及时发现，避免多主的问题。

- 有多种实现方案：基于ZOOKEEPER、基于redis等。

### 基于ZK实现

思路是：ZK是一个实现了分布式的一致性协调服务，zk提供了一个分布式一致性的命名空间，web实例在命名空间中可以类似于文件系统目录结构的方式创建节点，并且在节点上设置数据。

zk同时还提供了多种类型的监听器，通过监听器可以感知各类事件，包括连接成功、连接异常、session过期、节点数据变化、节点丢失、子节点变化等等。

- 利用事件监听器watch进行状态更新的回调。

    监听器可以实现回调函数，在回调函数中针对不同的事件类型实现相应的逻辑。


- 创建同路径的临时zk节点，zk节点内容为web serviceid，zk节点超时时间为锁超时时间。

    两个web实例可以尝试在zk的同一个路径创建相同的临时节点，节点的内容可以使自己的IP加port，zk每次只会让一个web实例创建成功。
    
    对于创建成功的实例而言，表示抢占锁成功了，已经获得了leader身份。而对于其他web实例，则会抛出节点已经存在的异常，表示加锁失败。

    临时节点可以设置超时时间，如果临时节点和leader节点的心跳断开了，临时节点会在超时时间达到后消失。


- 从节点需要注册zk临时节点监听器，监听节点失效事件。

    加锁失败的实例必须捕获到节点已经存在的异常，同时注册临时节点的监听器，如果发现临时节点失效了，表示当前的leader已经失效了，必须在回调函数中开启新一轮的锁抢占。

- 从节点都需要监听zk连接异常事件。

    所有web实例都需要关注zk连接、session过期异常，当leader节点发生异常事件的时候，表示锁已经或者即将失效，已经要丧失leader身份，需要终止服务逻辑，然后重连zk，并且尝试重新加锁。

    而从节点发现异常的时候，也需要重连zk，并且尝试重新加锁，如果加锁是发现节点已经存在，则继续监听。

    需要注意点的是，注册监听器的时候也有可能出现异常，比如节点刚好不在了，或者zk连接断开了等等。这些都需要特别注意，做好状态机的转移。

### 基于Redis实现

Redis是一个非常流行的缓存服务，和基于zk的实现类似，我们可以通过在Redis上set同一个key来实现加锁。

- Redis没有监听器回调机制，状态发现通过定期轮训来实现。

- web节点set同一个leader key，并且是 SET_IF_NOT_EXIST

    在set key的时候必须使用 SET_IF_NOT_EXIST，表示只有在key不存在的时候才能set成功。因此成功设置set的web表示已经成功抢占到了锁，value的内容依然可以是ip加port。

- leader key设置过期时间expireTime，续作锁必须保证原子性。

    由于Redis没有监听器回调机制，状态发现必须通过web的定期轮训来实现，主节点定期轮训续作锁的超时时间，这个操作必须保证锁的原子性。

### 两种方式的优缺点

- zk集群节点多，高可用，但是编程模型相对复杂

- redis的变成模型相对简单，redis自身有单点风险

- 其他：数据库乐观锁

## 如何实现web高可用-元数据同步

- 元数据同步

    - 哪些属于元数据：project，trigger， 元数据常驻内存

    - 元数据的任何修改都需要持久化到db
    
    - 元数据要有版本信息，project有version字段，trigger可以用最近更新时间

- web服务

    - 实现suspend，非主情况下拒绝访问&停止调度触发

    - 实现resume，从db中同步元数据，并恢复接口访问&调度

## 如何实现web高可用-避免双主

- 需要评估在网络异常的情况下web能在多少时间内发现，假设为T1，这个T就是：

    - ZK为connection/session异常事件的发现事件上限

    - Redis为锁轮训时间间隔

- 需要评估leader发现异常到完全停止服务的事件T2，一般就是调度轮训的时间间隔

- 从节点在resume的时候，至少需要等待T1+T2的时间

- 可能会出现最多T1+T2时间的无主

- web进程、多主监控依然不能停

[1]: https://github.com/jiaoqiyuan/163-bigdate-note/raw/master/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%EF%BC%9AAzkaban/img/azkaban_web_reality.png